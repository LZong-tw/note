## 如何在Rust中打印变量的类型？

```rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>())
}

fn main() {
   // Reference to str
   let s: &str = "Hello";
   print_type_of(&s);
 
   // String object
   let s_obj: String = String::from("Hello");
   print_type_of(&s_obj);

   let s = "Hello";
   let i = 42;

   print_type_of(&s); // &str
   print_type_of(&i); // i32
   print_type_of(&main); // playground::main
   print_type_of(&print_type_of::<i32>); // playground::print_type_of<i32>
   print_type_of(&{ || "Hi!" }); // playground::main::{{closure}}
}
```



### Ownership 的規則還有 copy 跟 move 的差異。

```rust
// https://ithelp.ithome.com.tw/articles/10222382

fn print_type_of<T>(_: &T)
{
    println!("{}", std::any::type_name::<T>())
}

fn move_vs_copy()
{
    // 這邊的 y 在記憶體中複製了一整份完整的資料
    let x = 5;
    let y = x;
    println!("{}", x);
    // s1 的指標和長度等資訊轉移給 s2
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}", s1);
                   ^^ value borrowed here after move
}

fn main()
{
    move_vs_copy();
}
```

各位可以看到這個例子在印出 x 時沒有問題但是怎麼卻沒辦法印出 s1 呢？因為 x 跟 y 用的是 copy 的方式但是 s1 跟 s2 用的是 move 的方式。



### Clone

如果需要完整地複製 heap 的資料 Rust 也有提供 clone 的方法如下，

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```



### Ownership and Functions

傳遞值給函式(function)時其實跟我們把值 assign 給變數時是類似的方式，也就是說當把值傳給函式時同樣會用 move 或是 copy 的方法處理，那麼我們就直接看個例子，

```rust
fn ownership_and_functions()
{
    let s = String::from("hello"); // s 現在在 scope 裡面

    takes_ownership(s); // 由於 s 是用 heap 法處理所以 move
    // 因此 s 的所有權已經被轉移了

    println!("s = {}", s); // 這時已經取得不了 s 編譯會報錯
    ^ value borrowed here after move

    let x = 5; // 反之如果是 stack 法處理

    makes_copy(x); // x 就會 copy 一份後進到函式裡面
    // 所以還是可以印得出 x 不會報錯
    println!("x = {}", x);
}

fn takes_ownership(some_string: String)
{
    println!("{}", some_string);
}

fn makes_copy(some_integer: i32)
{
    println!("{}", some_integer);
}
```

如果我們試著取得 s 在他 move 所有權之後編譯器就會報錯反之如果是用 copy 的方式處理的就不會。

### Return Values and Scope

而同樣當函式返回值的時候也會轉移所有權，例如下面的例子，

```rust
fn ownership_and_return_values()
{
    let s1 = gives_ownership(); // s1 的所有權是從 gives_ownership 來的, 其值為 "hello"

    let s2 = String::from("hello"); // 宣告一個新的變數 s2

    let s3 = takes_and_gives_back(s2); // s2 move 進 takes_and_gives_back
    // takes_and_gives_back, 同時也返回所有權, 現在 s3 擁有所有權

    println!("{}", s2); // 報錯因為 s2 的所有權已經轉移給 s3
    println!("{}", s3); // 不會報錯 s3 擁有所有權
}

fn gives_ownership() -> String {
    // gives_ownership 這支程式將會把 some_string 的擁有權
    // 傳出去給呼叫他的另外一個擁有者

    let some_string = String::from("hello"); // 宣告一個新的變數 some_string
    some_string // 返回 some_string, move 出去給呼叫他的擁有者
}

// 直接返回傳入的值
fn takes_and_gives_back(a_string: String) -> String {
    a_string
}
```

也就是說 ownership (所有權)會在函式之中被傳來傳去，但是同時也造成麻煩例如，

```rust
fn main()
{
    let s1 = String::from("hello");
    let(s2, len) = calculate_length(s1);
    println!("The length of '{}' is {}.", s2, len);
}

// 如果我們還需要使用 s 時必須再把他回傳
fn calculate_length(s: String) -> (String, usize)
{
    let length = s.len(); // 算出 String 的長度
    (s, length)
}
```

這樣的方式太攏長會造成寫程式時的不便，因此接下來會介紹 Rust `reference` 的概念。

### References

首先我們來稍微改寫一下上一篇的例子，

```rust
fn main()
{
    let s1 = String::from("hello");
    let len = calculate_length(&s1); // 傳遞 reference 但是沒有 ownership
    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
} // 因為沒有任何 ownership 所以 drop 也不會怎樣
```

各位注意到有什麼變化了嗎？

1. 函式的參數多了個 & 的符號
2. s1 還是可以使用 ownership 沒有被轉移

首先

- 第一點 & 的符號就代表這個參數是 reference
- 第二點 reference 讓你可以指到你要的值但是不需要轉移 ownership

我們借官網的圖來看比較好懂，



![](./images/20119807K6gOdVKusy.png)

