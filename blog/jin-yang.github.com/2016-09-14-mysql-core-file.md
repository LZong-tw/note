---
title: MySQL Core 文件
layout: post
comments: true
language: chinese
category: [mysql,database]
keywords: mysql,core,file
description: 簡單分析下 mysqld 進程關閉的過程，並討論如何安全地關閉 MySQL 實例。
---

Core 文件又稱為 Core Dump 文件，對於線上的服務而言，也就意味著進程異常；而且，如果進程佔用內存很大，但是 dump 到磁盤上，也會花很長時間。

當然，Core 雖然會終止掉當前進程，但是也會保留下第一手的現場數據，包括了進程被終止時內存、CPU寄存器等信息，可以供後續開發人員進行調試。

接下來，看看 MySQL 中 Core 文件的處理。

<!-- more -->

![core file logo]({{ site.url }}/images/databases/mysql/core-file-logo.jpg "core file logo"){: .pull-center width="50%"}

## 簡介

在開發一個程序時，程序可能會在運行過程中異常終止或者崩潰，這時操作系統就會把程序掛掉時的內存狀態記錄下來，並寫入一個叫做 Core 的文件中，這種行為就叫做 Core Dump 操作，通過這個文件可以方便的進行調試。

> 在使用半導體作為內存的材料前，人類使用的是線圈作為內存的材料，線圈叫做 Core，用線圈製作的內存就是 Core Memory。

除了內存信息之外，還有些關鍵的程序運行狀態也會同時 dump 下來，例如寄存器信息 (包括程序指針、棧指針等)、內存管理信息、其他處理器和操作系統狀態和信息；而這些信息對於編程人員診斷和調試程序是非常有幫助。

> A core dump is the recorded state of the working memory of a computer program at a specific time, generally when the program has terminated abnormally (crashed). In practice, other key pieces of program state are usually dumped at the same time, including the processor registers, which may include the program counter and stack pointer, memory management information, and other processor and operating system flags and information. The name comes from the once-standard memory technology core memory. Core dumps are often used to diagnose or debug errors in computer programs.
>
> On many operating systems, a fatal error in a program automatically triggers a core dump, and by extension the phrase "to dump core" has come to mean, in many cases, any fatal error, regardless of whether a record of the program memory is created.

### 開啟CoreDump

可以使用命令 ulimit 開啟，也可以在程序中通過 setrlimit 系統調用開啟；先介紹下前者配置方式。

{% highlight text %}
----- 查看配置，如果為0，則說明未開啟
$ ulimit -c

----- 設置轉儲文件大小，單位是blocks(KB)，unlimited表示不限
# ulimit -c unlimited

----- 設置轉儲文件大小為100KB
# ulimit -c 100
{% endhighlight %}

當設置為 unlimited 時，則表示不限制內核轉儲文件的大小，發生問題時所有的內存都將轉儲到文件中；對於大量消耗內存的程序可以限制轉儲文件的大小。

如果要持久化，可以修改 ```/etc/security/limits.conf``` 文件即可，參考如下示例。

{% highlight text %}
#<domain>      <type>  <item>         <value>
    *           soft    core          unlimited
{% endhighlight %}

默認生成的 core 文件保存在可執行文件所在目錄下，文件名為 core；當然，也可以通過如下方式進行設置。

{% highlight text %}
----- 添加PID後綴
# echo 1 > /proc/sys/kernel/core_uses_pid

----- 設置輸出目錄，格式為core-命令名-PID-時間戳
# echo "/tmp/core-%e-%p-%t" > /proc/sys/kernel/core_pattern

常見參數：
   %t: 設置文件轉儲時的 unix 時間，從 1970.1.1 0:00:00 開始的秒數。
   %e: 執行的命令名。
   %p: 被轉儲進程的 PID 。
   %u: 被轉儲進程的真實用戶 ID ，也即 UID 。
   %g: 被轉儲進程的真實組 ID ，也即 GID 。
   %s: 引發轉儲的信號編號。
   %h: 主機名，同 uname(2) 返回的 nodename 。
   %c: 轉儲文件大小的上限，2.6.24 以後可以使用。
{% endhighlight %}

設置完 core_pattern 之後，core_user_pid 會無效，也可以通過 sysctl 進行設置。

{% highlight text %}
# cat /etc/sysctl.conf
kernel.core_pattern = /var/%e-%p-%t.core
kernel.core_user_pid = 0
# sysctl -p
{% endhighlight %}


### 測試示例

可以在程序執行期間發送 SIGSEGV(11) 信號，也即 ```Ctrl+\``` 快捷鍵。

{% highlight text %}
----- 使用Ctrl+\退出程序，產生core dump
$ sleep 100
^\Quit (core dumped)

----- 或者發送SIGSEGV(11)信號
# kill -s SIGSEGV $$
# kill -11 <pid>
{% endhighlight %}

接著看一個簡單的示例程序。

{% highlight text %}
$ cat << EOF > create_core.c
int a (int *p)
{
  int y = *p;
  return y;
}
int main (void)
{
  int *p = NULL;
  *p = 0;         // 訪問0地址，發生Segmentation fault錯誤
  return a (p);
}
EOF
$ gcc -Wall -g create_core.c -o create_core
$ ./create_core
Segmentation fault (core dumped)
{% endhighlight %}

也可以通過 API 進行設置，不過此時編譯之後，在運行時需要 root 權限。

{% highlight cpp %}
#include <stdio.h>
#include <unistd.h>
#include <sys/resource.h>
#define CORE_SIZE   1024 * 1024 * 500
int main(void)
{
    struct rlimit rlmt;
    if (getrlimit(RLIMIT_CORE, &rlmt) == -1)
        return -1;
    printf("Before set rlimit CORE dump current is:%d, max is:%d\n",
           (int)rlmt.rlim_cur, (int)rlmt.rlim_max);

    rlmt.rlim_cur = (rlim_t)CORE_SIZE;
    rlmt.rlim_max  = (rlim_t)CORE_SIZE;
    if (setrlimit(RLIMIT_CORE, &rlmt) == -1)
        return -1;
    if (getrlimit(RLIMIT_CORE, &rlmt) == -1)
        return -1;
    printf("After set rlimit CORE dump current is:%d, max is:%d\n",
           (int)rlmt.rlim_cur, (int)rlmt.rlim_max);

    int *ptr = NULL;  // 測試非法內存，產生core文件
    *ptr = 10;
    return 0;
}
{% endhighlight %}

在調試時可以通過 ```gdb program core-file``` 調試，當然編譯時，需要加上調試信息 (-g)。

{% highlight text %}
$ gdb core_demo core_demo.core.24816
...
Core was generated by './core_demo'.
Program terminated with signal 11, Segmentation fault.
#0  0x080483cd in func (p=0x0) at core_demo.c:5
5       int y = *p;
(gdb)  where                        # 或者backtrace
#0  0x080483cd in func (p=0x0) at core_demo.c:5
#1  0x080483ef in main () at core_demo.c:12
(gdb) info frame
Stack level 0, frame at 0xffd590a4:
 eip = 0x80483cd in func (core_demo.c:5); saved eip 0x80483ef
 called by frame at 0xffd590c0
 source language c.
 Arglist at 0xffd5909c, args: p=0x0
 Locals at 0xffd5909c, Previous frame's sp is 0xffd590a4
 Saved registers:
  ebp at 0xffd5909c, eip at 0xffd590a0
{% endhighlight %}

從上面可以看出，可以還原 core_demo 執行時的場景，使用 where 或者 backtrace 查看當前程序調用函數棧幀，來定位 core dump 的文件行，還可以查看寄存器、變量等信息。

也可以通過如下方式查看。

{% highlight text %}
$ gdb -c core_demo.core.24816 core_demo
{% endhighlight %}


### 其它

{% highlight text %}
----- 查找core文件，以及文件類型
# find $HOME -name "core*"
/home/oli/core.6440
# file core
core:      ELF 32-bit LSB core file Intel 80386, version 1 (SYSV), SVR4-style

----- 查看是那個進程信息
# strings core.6440 | head
{% endhighlight %}

可以在 core_pattern 中加入管道符，然後調用用戶程序，例如將轉儲文件壓縮。

{% highlight text %}
# echo "|/usr/local/sbin/core_helper %e %p %t" > /proc/sys/kernel/core_pattern

$ cat /usr/local/sbin/core_helper
#!/bin/sh
exec gzip - > /var/$1-$2-$3.core.gz
$ gunzip -c /var/xxx-xxx-xxx.core.gz > ~/xxx-xxx-xxx.core
{% endhighlight %}

可以將 ```ulimit -S -c unlimited > /dev/null 2>&1``` 使用戶登陸時即可以設置轉儲功能。默認內核會轉儲共享內存，可以設置排除共享內存。




<!--
Dump more information
# cat /proc/<pid>/coredump_filter
00000003

The following 4 memory types are supported:
    (bit 0) anonymous private memory
    (bit 1) anonymous shared memory
    (bit 2) file-backed private memory
    (bit 3) file-backed shared memory

# echo 0xF > /proc/<pid>/coredump_filter
Finding the limits of a process
# egrep "Units|core" /proc/<pid>/limits
Limit                     Soft Limit           Hard Limit           Units
Max core file size        1024000              1024000              bytes
-->



## debuginfo

為了能夠使用 gdb 跟蹤調試程序，需要在編譯期使用 -g 選項；而對於系統庫或是 Linux 內核，使用 gdb 調試或使用 systemtap 探測時，還需要安裝相應的 debuginfo 包。

例如 glibc 及它的 debuginfo 包。

{% highlight text %}
# yum --enablerep=base-debuginfo install glibc-debuginfo

$ rpm -qa | grep glibc
glibc-2.17-157.el7_3.1.x86_64
glibc-debuginfo-2.17-157.el7_3.1.x86_64
{% endhighlight %}

接下來，我們看看 debuginfo 包中包含了那些信息，該包是如何製作的，而且 glibc 和 debuginfo 是如何關聯起來的。

### 包含信息

首先看看 glibc-debuginfo 包中包含有什麼內容。

{% highlight text %}
$ rpm -ql glibc-debuginfo
/usr/lib/debug
/usr/lib/debug/.build-id
/usr/lib/debug/.build-id/00
/usr/lib/debug/.build-id/00/98d7f56d263e087a1abad592e81e3e79e26652
/usr/lib/debug/.build-id/00/98d7f56d263e087a1abad592e81e3e79e26652.debug
... ...
/usr/lib/debug/lib64
/usr/lib/debug/lib64/ld-2.17.so.debug
/usr/lib/debug/lib64/ld-linux-x86-64.so.2.debug
/usr/lib/debug/lib64/libBrokenLocale-2.17.so.debug
/usr/lib/debug/lib64/libBrokenLocale.so.1.debug
... ...
/usr/src/debug/glibc-2.17-c758a686
/usr/src/debug/glibc-2.17-c758a686/argp
/usr/src/debug/glibc-2.17-c758a686/argp/argp-ba.c
/usr/src/debug/glibc-2.17-c758a686/argp/argp-eexst.c
/usr/src/debug/glibc-2.17-c758a686/argp/argp-fmtstream.c
... ...
{% endhighlight %}

可以看出，glibc-debuginfo 大致有三類文件：

存放在/usr/lib/debug/下的：.build-id/nn/nnn...nnn.debug文件，文件名是hash key。
存放在/usr/lib/debug/下的其它*.debug文件，其文件名，是庫文件名+.debug後綴。
glibc的源代碼

當使用 gdb 調試時，需要在機器碼與源代碼之間，建立起映射關係，這就需要三個信息：

* 機器碼：可執行文件、動態鏈接庫，例如上面的/lib64/libc-2.18.so；
* 源代碼：顯然就是glibc-debuginfo中，包含的*.c和*.h等源文件；
* 映射關係：也就是保存在*.debug文件中的信息。

### 如何生成

通過 gcc -g 編譯時，默認機器碼與源代碼的映射關係會與可執行程序、動態鏈接庫合併在一起；但是這樣就導致文件特別大，而對於普通用戶來說是不需要的。

正是了為解決這個問題，在 Linux 上的各種程序和庫，在生成 RPM 時，就已經把 debuginfo 單獨的抽取出來，因此形成了獨立的 debuginfo 包。

{% highlight text %}
$ cat << EOF > foobar.c
#include <stdio.h>
int main(void)
{
    printf("Hello World!!!\n");
    return 0;
}
EOF

----- 其中參數-ggdb生成gdb格式調試信息
$ gcc -ggdb foobar.c -o foobar

----- 創建一個包含debuginfo的文件
$ objcopy --only-keep-debug foobar foobar.debug

----- 清除原執行文件中的調試信息，如下兩個操作相同
$ objcopy --strip-debug foobar
$ strip --strip-debug foobar

----- 此時嘗試加載調試符號時會報錯
$ gdb foobar
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7
... ...
Reading symbols from /tmp/foobar...(no debugging symbols found)...done.
(gdb)

----- 當然，現在可以指定gdb需要加載的debuginfo即可，如下兩者相同
$ gdb foobar -s foobar.debug
$ gdb
(gdb) file foobar
(gdb) symbol foobar.debug
{% endhighlight %}

顯然，gdb 現在無法找到調試信息了；我們需要告訴 gdb 如何正確地找到它對應的 debug 文件，也就是上述的 foobar.debug 文件。

對於 Linux 下的 ELF(Executable and Linkable Format) 格式文件，可以通過一個 .gnu_debuglink 段來保存信息，可通過 ```objcopy --add-gnu-debuglink``` 添加。

{% highlight text %}
----- 添加一個包含路徑文件的.gnu_debuglink section
$ objcopy --add-gnu-debuglink=foobar.debug foobar

----- 查看.gnu_debuglink section
$ objdump -s -j .gnu_debuglink foobar
foobar:     file format elf64-x86-64
Contents of section .gnu_debuglink:
 0000 666f6f62 61722e64 65627567 00000000  foobar.debug....
 0010 ba8924f6

----- 現在可以直接調試了
$ gdb foobar
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7
... ...
Reading symbols from /tmp/test/foobar...Reading symbols from /tmp/test/foobar.debug...done.
done.
(gdb)
{% endhighlight %}

上面的 objcopy 是把 foobar.debug 的文件名以及這個文件的 CRC 校驗碼，寫到了.gnu_debuglink 這個 ELF 的頭部值中，但是並沒有告訴 foobar.debug 所在的路徑。

### 搜索路徑

在 Linux 中，在編譯時會根據時間戳生成 build-id，並保存到 ```gnu.build-id section``` 中；可以通過如下命令查看 ```"gnu.build-id" section``` 信息。

{% highlight text %}
$ readelf -n foobar
$ readelf -t foobar |grep build-id
$ readelf --wide --sections foobar |grep build
$ objdump -s -j .note.gnu.build-id foobar
{% endhighlight %}

而 gdb 默認會搜索指定目錄 (```show debug-file-directory```) 下與 build-id 關聯的 .debug 文件。默認 gdb 搜索的文件名為 NN/N...N.debug, 前兩個 "NN" 就是 build-id 前兩位，後面的 N...N 則是 build-id 的剩餘部分，只是改了個文件名而已。

而 gdb 則是通過下面的順序查找 foobar.debug 文件：

{% highlight text %}
1. <global debug directory>/.build-id/nn/nnnn...nnnn.foobar.debug
2. <the path of foobar>/foobar.debug
3. <the path of foobar>/.debug/foobar.debug
4. <global debug directory>/<the patch of foobar>/foobar.debug
{% endhighlight %}

而 ```<global debug directory>``` 默認為 /usr/lib/debug/；可以通過 ```set/show debug-file-directory``` 命令來設置或查看這個值。

{% highlight text %}
(gdb) show debug-file-directory
(gdb) set debug-file-directory PATH
{% endhighlight %}

假設 foobar 的 Build ID 為 ```3bda624ab466b7725faaf5cde424a5674a741c5d```，可將 foobar.debug 文件移動到 ```/usr/lib/debug/.build-id/3b/da624ab466b7725faaf5cde424a5674a741c5d.debug``` 。

<!-- readelf -S utmp -->

foobar.debug 默認會採用 DWARF 4 格式來保存調試信息，可以通過 ```readelf -w foobar.debug``` 來查看 DWARF 的內容；詳見 [DWARF Debugging Information Format Version 4](http://dwarfstd.org/doc/DWARF4.pdf) 。

### 生成Marker探針

通過 gcc -g 命令，所有函數名都會自動的生成相應的 debuginfo，供 systemtap 進行探測，<!--這種方法在英文上稱為：Debuginfo-based instrumentation，-->其侷限性在於，只能收集到函數調用的初始時刻、以及函數返回的結束時刻的上下文信息。

為瞭解決這個問題，又提出了一種新方法 ```Compiled-in instrumentation```，可以把探針安插到指定的某行代碼中，從而可以收集到那行代碼執行時的上下文信息，這種探針被稱為 Marker 探針。

編寫 Marker 探針，示例如下：

{% highlight text %}
#include <sys/sdt.h>
DTRACE_PROBE(provider, name)
DTRACE_PROBE4(provider, name, arg1, arg2, arg3, arg4)
{% endhighlight %}

寫好 Marker 探針併成功編譯後，可以使用下面的 systemtap 指令來查看 Marker 探針是否生效。

{% highlight text %}
stap -L 'process("/path/to/foobar").mark("*")'
{% endhighlight %}

<!--
更具體的操作方法詳見文獻6，值得一提的是，Marker探針是非常輕量的，它幾乎對程序的性能沒有影響，因為它只會在代碼中生成nop彙編指令。它是通過把現場的上下文信息，保存在ELF文件的特定的section header(.stapsdt.base)來實現的，只會增加debuginfo文件的大小。
-->

詳細可以參考 [Adding User Space Probing to an Application (heapsort example)](https://sourceware.org/systemtap/wiki/AddingUserSpaceProbingToApps) 。


## MySQL

對於一般進程，要讓進程崩潰時能生成 core file 用於調試，只需要設置 rlimit 的 core file size > 0 即可；比如，用在 ```ulimit -c unlimited``` 時啟動程序。

對 MySQL 來說，由於 core file 中會包含表空間的數據，所以默認情況下為了安全，mysqld 捕獲了 SEGV 等信號，崩潰時並不會生成 core file，需要在 my.cnf 或啟動參數中加上 core-file 。

{% highlight text %}
[mysqld]
core_file = ON
{% endhighlight %}

但是即使做到了以上兩點，在 mysqld crash 時可能還是無法 core dump 。

如果程序通過 ```seteuid()/setegid()``` 系統調用，改變了進程的有效用戶或組，則在默認情況下系統不會為這些進程生成 CoreDump 。簡單來說，如果你當初是以用戶 A 運行了某個程序，但在 ps 裡看到的這個程序的用戶卻是 B 的話，那麼這些進程就是調用了 seteuid 了。

對於 MySQL 來說，無論通過什麼用戶利用 mysqld_safe 啟動，mysqld 的有效用戶始終是 mysql 用戶；為了能讓 MySQL 生成 core dump，需要設置 ```/proc/sys/fs/suid_dumpable``` 文件的內容改為 1 。

<!--
還有一些系統參數會影響 core dump。以下腳本可供參考：

echo 2 >/proc/sys/fs/suid_dumpable
chmod 0777 /var/crash
echo /var/crash/core> /proc/sys/kernel/core_pattern
echo 1 >/proc/sys/kernel/core_uses_pid
-->

之後，就可以用 kill -SEGV 讓 mysqld 崩潰，測試一下能不能正常產生 core file 了。


## 參考

關於 Core Dump 的常用命令可以參考 [Hunting the core](http://www.fromdual.com/hunting-the-core) 。

對於如何分離 debuginfo 文件可以參考 [Debugging Information in Separate Files](https://sourceware.org/gdb/onlinedocs/gdb/Separate-Debug-Files.html) 。


<!--
https://www.percona.com/blog/2011/08/26/getting-mysql-core-file-on-linux/

深入理解debuginfo
http://blog.csdn.net/chinainvent/article/details/24129311?reload
-->

{% highlight text %}
{% endhighlight %}
