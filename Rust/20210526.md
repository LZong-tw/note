## 如何在Rust中打印变量的类型？

```rust
fn print_type_of<T>(_: &T) {
    println!("{}", std::any::type_name::<T>())
}

fn main() {
   // Reference to str
   let s: &str = "Hello";
   print_type_of(&s);
 
   // String object
   let s_obj: String = String::from("Hello");
   print_type_of(&s_obj);

   let s = "Hello";
   let i = 42;

   print_type_of(&s); // &str
   print_type_of(&i); // i32
   print_type_of(&main); // playground::main
   print_type_of(&print_type_of::<i32>); // playground::print_type_of<i32>
   print_type_of(&{ || "Hi!" }); // playground::main::{{closure}}
}
```

### Rust 的字串有以下兩種：

- String 類別是以 UTF8 編碼、可伸縮的字串
- str 是基礎型別，通常是使用 &str，即指向 str 的參考

另外，Rust 還有字元 (char) 型別，同樣也是以 UTF8 編碼。

建立字串常數時，預設型別是 &str，即指向 str 的參考，但是，若想要使用 String 類別的方法時，可以轉為 String 物件。

```rust
fn main () {
    // Reference to str, str 是基礎型別，通常是使用 &str，即指向 str 的參考
    let x = "hello world";
    let y = x;
    println!("{:p}", x.as_ptr());
    println!("{:p}", y.as_ptr());


    // String object, str 是基礎型別，通常是使用 &str，即指向 str 的參考
    let s_obj: String = String::from("Hello");
    let s1_obj = s_obj;
                 ^^^^^^^^^^^^^^ value borrowed here after move
    println!("{:p}", s_obj.as_ptr());
    println!("{:p}", s1_obj.as_ptr());
}
```

### Move, Borrow & Ownership

Rust 中可說是最複雜，卻也是最重要的一個觀念，變數的所有權 (ownership) ，在 Rust 中每個變數都有其所屬的範圍 (scope) ，在變數的有效的範圍中，可以選擇將變數「借 (borrow)」給其它的 scope ，也可以將所有權整個轉移 (move) 出去，送給別人喔，當然，送出去的東西如果別人不還你的話是拿不回來的，但借出去的就只是暫時的給別人使用而已。

```rust
fn main()
{
    let message = String::from("Hello");
    {
        message;
    }
    println!("{}", message);
                   ^^^^^^^ value borrowed here after move 
}
```

### Ownership 的規則還有 copy 跟 move 的差異。

```rust
// https://ithelp.ithome.com.tw/articles/10222382

fn print_type_of<T>(_: &T)
{
    println!("{}", std::any::type_name::<T>())
}

fn move_vs_copy()
{
    // 這邊的 y 在記憶體中複製了一整份完整的資料
    let x = 5;
    let y = x;
    println!("{}", x);
    // s1 的指標和長度等資訊轉移給 s2
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}", s1);
                   ^^ value borrowed here after move
}

fn main()
{
    move_vs_copy();
}
```

各位可以看到這個例子在印出 x 時沒有問題但是怎麼卻沒辦法印出 s1 呢？因為 x 跟 y 用的是 copy 的方式但是 s1 跟 s2 用的是 move 的方式。



### Clone

如果需要完整地複製 heap 的資料 Rust 也有提供 clone 的方法如下，

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```



### Ownership and Functions

傳遞值給函式(function)時其實跟我們把值 assign 給變數時是類似的方式，也就是說當把值傳給函式時同樣會用 move 或是 copy 的方法處理，那麼我們就直接看個例子，

```rust
fn ownership_and_functions()
{
    let s = String::from("hello"); // s 現在在 scope 裡面

    takes_ownership(s); // 由於 s 是用 heap 法處理所以 move
    // 因此 s 的所有權已經被轉移了

    println!("s = {}", s); // 這時已經取得不了 s 編譯會報錯
    ^ value borrowed here after move

    let x = 5; // 反之如果是 stack 法處理

    makes_copy(x); // x 就會 copy 一份後進到函式裡面
    // 所以還是可以印得出 x 不會報錯
    println!("x = {}", x);
}

fn takes_ownership(some_string: String)
{
    println!("{}", some_string);
}

fn makes_copy(some_integer: i32)
{
    println!("{}", some_integer);
}
```

如果我們試著取得 s 在他 move 所有權之後編譯器就會報錯反之如果是用 copy 的方式處理的就不會。

### Return Values and Scope

而同樣當函式返回值的時候也會轉移所有權，例如下面的例子，

```rust
fn ownership_and_return_values()
{
    let s1 = gives_ownership(); // s1 的所有權是從 gives_ownership 來的, 其值為 "hello"

    let s2 = String::from("hello"); // 宣告一個新的變數 s2

    let s3 = takes_and_gives_back(s2); // s2 move 進 takes_and_gives_back
    // takes_and_gives_back, 同時也返回所有權, 現在 s3 擁有所有權

    println!("{}", s2); // 報錯因為 s2 的所有權已經轉移給 s3
    println!("{}", s3); // 不會報錯 s3 擁有所有權
}

fn gives_ownership() -> String {
    // gives_ownership 這支程式將會把 some_string 的擁有權
    // 傳出去給呼叫他的另外一個擁有者

    let some_string = String::from("hello"); // 宣告一個新的變數 some_string
    some_string // 返回 some_string, move 出去給呼叫他的擁有者
}

// 直接返回傳入的值
fn takes_and_gives_back(a_string: String) -> String {
    a_string
}
```

也就是說 ownership (所有權)會在函式之中被傳來傳去，但是同時也造成麻煩例如，

```rust
fn main()
{
    let s1 = String::from("hello");
    let(s2, len) = calculate_length(s1);
    println!("The length of '{}' is {}.", s2, len);
}

// 如果我們還需要使用 s 時必須再把他回傳
fn calculate_length(s: String) -> (String, usize)
{
    let length = s.len(); // 算出 String 的長度
    (s, length)
}
```

這樣的方式太攏長會造成寫程式時的不便，因此接下來會介紹 Rust `reference` 的概念。

### References

首先我們來稍微改寫一下上一篇的例子，

```rust
fn main()
{
    let s1 = String::from("hello");
    let len = calculate_length(&s1); // 傳遞 reference 但是沒有 ownership
    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
} // 因為沒有任何 ownership 所以 drop 也不會怎樣
```

各位注意到有什麼變化了嗎？

1. 函式的參數多了個 & 的符號
2. s1 還是可以使用 ownership 沒有被轉移

首先

- 第一點 & 的符號就代表這個參數是 reference
- 第二點 reference 讓你可以指到你要的值但是不需要轉移 ownership

我們借官網的圖來看比較好懂，



![](./images/20119807K6gOdVKusy.png)

因此 references(參照) 字面上來說就跟實際行為蠻像的，感覺就是請你參照他就好但我不必擁有他。

那麼如果我們想要修改 borrowing(借)來的 references 的呢？舉個例子，

```rust
fn main() {
    let s = String::from("hello");
    unchangeable(&s);
}

fn unchangeable(some_string: &String) {
    some_string.push_str(", world");
    ^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable
}
```



在編譯時就會報錯，因為這個 reference 指向的是 immutable 的變數所以我們並不能修改他。

## Mutable References

前面的例子除非改成 mutable 才可以修改，例如，

```rust
fn changeable(some_string: &mut String)
{
    some_string.push_str(", world");
}

fn main()
{
    let mut s = String::from("hello");
    changeable(&mut s);
    println!("s = {}", s); // s = hello, world
}
```

這樣就可以編輯，但是 Rust 對這樣的寫法有很大的限制，在同一個 scope 不能同時宣告 2 個以上的 mutable reference 因此像是這個例子就會報錯，

```rust
fn cause_error()
{
    let mut s = String::from("hello");
    let r1 = &mut s;
    let r2 = &mut s;
    ^^^^^^ second mutable borrow occurs here
    println!("{}, {}", r1, r2);
}
```

而主要的原因是 Rust 要避免在編譯期間造成 data race， data race 類似於 race condition 他通常發生於下列三種情況，

- 2 個以上的 mutable reference 同時取得同一個值
- 至少一個 pointer 被用來寫入資料
- 沒有同步訪問數據的機制

[這裡](https://en.wikipedia.org/wiki/Race_condition)有 wiki 的補充資料可以更了解 race condition，簡單來說就是處理資料時的先後順序沒處理好而導致資料錯誤的情況。

基本上 data race 會造成 undefined 而且不容易找出 bug，而這也是 Rust 希望可以幫助工程師避免的情況，所以才會有這樣的限制，基本上就算沒有限制筆者也會避免這樣的設計方式，除非有非常不得已的理由。

同樣的錯誤也會出現在同時擁有 immutable 跟 mutable reference 的 scope 裡面例如，

```rust
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
let r3 = &mut s; // BIG PROBLEM
         ^^^^^^ mutable borrow occurs here

println!("{}, {}, and {}", r1, r2, r3);
```

這個錯的情況很容易理解，我們不能給了 immutable 的 reference 之後又他給 mutable 的 reference 你到底是要我變還是不變呢？

另外是 reference 的 scope 從被宣告開始到最後一次被使用之後就結束了所以像是這個例子是可以的，

```rust
fn this_work()
{
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{} and {}", r1, r2);
    // 在這之後不再使用 r1 和 r2

    let r3 = &mut s; // no problem
    println!("{}", r3);
}
```

同要的道理我先 mutable 再 immutable 也是可以的例如，

```rust
fn this_still_work()
{
    let mut s = String::from("hello");
    let r1 = &mut s;
    // 在這之後不再使用 r1
    let r2 = &s;
    let r3 = &s;
    println!("{} {}", r2, r3);
}
```

還有如果在不同 scope 例如這樣也是可以的，

```rust
fn this_work_too()
{
    let mut s = String::from("hello");

    {
        let r1 = &mut s;

    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &mut s;
}
```

## Dangling References

[迷途指標](https://zh.wikipedia.org/wiki/迷途指针)，筆者我比較喜歡這個翻法比較直覺，簡單來說就是值已經被釋放了但是 reference 沒有收回來。

不過完全不用擔心因為 Rust 說保證不會發生這個情況他會在編譯時幫我們做檢查，來看這個例子，

```rust
fn main() {
    let reference_to_nothing = dangling_references();
}

// help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
fn dangling_references() -> &String {
                            ^ help: consider giving it a 'static lifetime: `&'static`
  let s = String::from("hello");
  &s
} // s 在這邊已經離開 scope 了但是卻回傳了他的 reference，因此就會造成迷途指標。
```

這邊要這樣改才會正常

```rust
fn main()
{
    let reference_to_nothing = no_dangling_references();
}

fn no_dangling_references() -> String {
    let s = String::from("hello");
    s
}
```

