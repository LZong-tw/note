# 強制進程產生coredump，檢測死鎖以及進程快照


在軟件開發的過程中，無論如何努力，bug幾乎都是必不可少的。當某些bug發生時，該進程會產生coredump文件。通過這個coredump文件，開發人員可以找到bug的原因。但是coredump的產生，大都是因為程序crash了。

而有些bug是不會導致進程crash的，比如死鎖——這時，程序已經不正常了，可是卻沒有coredump產生。如果環境又不允許gdb調試，難道我們就束手無策了嗎？針對這種情況，一般情況下，對於這樣的進程，可以利用watchdog監控它們，當發現這些進程很長時間沒有更新其heartbeat時，可以給這些進程發送可以導致其產生coredump的信號。根據linux的信號默認的處理行為，SIGQUIT，SIGABRT, SIGFPE和SIGSEGV都可以讓該進程產生coredump文件。這樣我們可以通過coredump來得知死鎖是否發生。當然，如果進程添加了這些信號的處理函數，那麼就不會產生coredump了。不過，對於SIGABRT, SIGFPE, SIGSEGV，有誰會為它們加上信號處理函數呢。

還有一種情況，進程並沒有死鎖或者block在某個位置，但是我們需要在某個指定位置進行調試，獲取某些變量或者其它信息。但是，有可能是客戶環境或者生產環境，不允許我們進行長時間的檢測。那麼，我們就需要通過coredump來獲得進程在運行到該點時的快照。
這個時候，可以利用gdb來產生手工產生coredump。在attach上這個進程時，在指定位置打上斷點，當斷點觸發時，使用gdb的命令gcore，可以立即產生一個coredump。這樣，我們就拿到了這個位置的進程快照。