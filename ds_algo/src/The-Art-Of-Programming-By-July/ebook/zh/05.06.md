## 最長遞增子序列

### 題目描述

給定一個長度為N的數組a0,a1,a2...,an-1，找出一個最長的單調遞增子序列（注：遞增的意思是對於任意的i<j，都滿足ai<aj，此外子序列的意思是不要求連續，順序不亂即可）。例如：給定一個長度為6的數組A{5， 6， 7， 1， 2， 8}，則其最長的單調遞增子序列為{5，6，7，8}，長度為4。

### 分析與解法

#### 解法一：轉換為最長公共子序列問題

比如原數組為
 - A{5， 6， 7， 1， 2， 8}，
 
當我們對這個數組進行排序後，排序後的數組為：
 - A‘{1， 2， 5， 6， 7， 8}。
 
然後想求數組A的最長遞增子序列，其實就是求數組A與它的排序數組A‘的最長公共子序列，原因是原數組A的子序列順序保持不變，而且排序後A‘本身就是遞增的，這樣，就保證了兩序列的最長公共子序列的遞增特性。

如此，若想求數組A的最長遞增子序列，其實就是求數組A與它的排序數組A‘的最長公共子序列。

#### 解法二：動態規劃

想到這個問題不能改變元素各自的相對順序，所以我們不能排序，在不能排序的情況下，我們考慮下是否能用動態規劃解決。

定義dp[i]為以ai為末尾的最長遞增子序列的長度，故以ai結尾的遞增子序列
 - 要麼是隻包含ai的子序列
 - 要麼是在滿足j<i並且aj<ai的以ai為結尾的遞增子序列末尾，追加上ai後得到的子序列
 
如此，便可建立遞推關係，在O(N^2)時間內解決這個問題。參考代碼如下：
```c
int n;
int a[n];

int dp[n];

void lis()
{
	int res = 0;
	int i;
	for (i = 0; i < n; i++)
	{
		dp[i] = (dp[i] > dp[i + 1] )? dp[i]:dp[i + 1];
	}
	res = (res > dp[i])?res:dp[i];
	printf("%d\n,res");
}
```
