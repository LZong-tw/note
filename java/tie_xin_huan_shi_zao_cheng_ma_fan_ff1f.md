# 貼心還是造成麻煩？


Java 將例外區分為受檢例外與非受檢例外，在例外繼承架構中，Exception子類但`非RuntimeException子類`，就是`受檢例外`，這類例外必須明 確在程式碼中聲明使用try..catch處理，或者在方法上使用throws宣告此方法會丟出的受檢例外。

`RuntimeException子類的例 外，則通常是JVM會自行丟出的例外`，不用特別使用程式碼處理，編譯器也會讓你通過編譯。


例外處理的本意是，在程式錯誤發生時，能夠有明確的方式通知API客戶端，`讓客戶端採取進一步的動作修正錯誤`，而就撰寫本文的時間點來說，Java是唯一採用受檢例外（Checked exception）的語言，這有兩個目的：一是文件化，受檢例外宣告會是API操作介面的一部份，客戶端只要查閱文件，就可以知道方法可能會引發哪些例外，並事先加以處理，而這是API設計者決定是否拋出受檢例外時的考量之一，另一個目的是提供編譯器資訊，`讓編譯器能夠在編譯時期就檢查出API客戶端沒有處理例外`。



也可以考慮為應用程式自訂專屬例外類別，讓例外更能表現應用程式特有的錯誤資訊。自訂例外類別時，可以繼承Throwable、Error或Exception的相關子類別，通常建議繼承自Exception，如果不是繼承自Error或RuntimeException，那麼就會是受檢例外。

```java
public class CustomizedException extends Exception { // 自訂受檢例外的一個例子
    ...
}
```
錯誤發生時，如果上下文環境並沒有足夠的資訊讓你處理例外，你可以就現有資訊處理完例外後，重新拋出例外，既然你已經針對錯誤做了某些處理，那麼也就可以考慮自訂例外，用以更精確地表示出未處理的錯誤，如果認為呼叫API的客戶端應當有能力處理未處理的錯誤，那就自訂受檢例外、填入適當錯誤訊息並重新拋出，並在方法上使用throws加以宣告，如果認為呼叫API的客戶端沒有準備好就呼叫了方法，才會造成還有未處理的錯誤，那就自訂非受檢例外、填入適當錯誤訊息並重新拋出。

```java
public class CustomizedException extends RuntimeException { // 自訂非受檢例外的一個例子
    ...
}
```

