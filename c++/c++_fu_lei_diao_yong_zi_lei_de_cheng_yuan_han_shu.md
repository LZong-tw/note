# C++: 父類調用子類的成員函數

C++ 中，父類是沒法調用到子類的成員函數的。當然，`靜態函數`可以被父類調用到；這裡只說普通函數。所以不能，`是因為父類的定義中，還沒有見到子類的定義，所以沒法引用到子類的成員函數`。
上面說的是在直接調用上，做不到。那麼有沒有別的方式做到呢？其實方法是有的。就是通過函數指針。當然，成員函數指針與一般函數指針有所區別。
例子如下：


```cpp
#include <stdio.h>
class c2;
class c1
{
public:
    c2* c;
    void (c2::*f)(int);
    void f1()
    {
        (c->*f)(123); // 這裡就可以隨便調了，只要對c、f都賦好值了。
        // 如果要把子類同一類成員函數通過函數指針數組方式調用，
        // 那麼也類似地當然是可以實現的
        // 注意這裡的括號與*，都需要
    }
};

class c2: public c1
{
public:
    void f2(int i)
    {
        printf("f2(%d);\n", i);
    }
    void f3()
    {
        c = this;       // 傳對象的指針。成員函數訪問需要通過對象，所以還必須用它
        f = &c2::f2; // 給函數指針賦值
    }
};

int main()
{
    c2 c;
    c.f3();
    c.f1();
    return 0;
}
```

執行結果為：
```sh
f2(123);
```
上面實際上也演示了成員函數指針的用法。


那麼，只能通過成員函數指針嗎？有沒有別的方法了?其實還有個方法是通過模板類，至於怎麼做，具體就看例子吧：

```cpp
#include<stdio.h>
template<typename T>
class c1
{
public:
    T* t;
    void f1()
    {
        printf("%d\n",
               t->xxx); // t 是模板類型T的指針，這樣即使不知道t的具體定義,
        // 也可以訪問到其成員，可以調用到其方法
        // 若非通過模板，就不能這樣
        t->f2();
    }
};

class c2: public c1<c2> // 這樣這裡
{
public:
    void f2()
    {
        printf("f2()\n");
    }
    int xxx ;
    void f3()
    {
        xxx = 123;
        t = this;   // 這個需要這樣設置
    }
};

int main()
{
    c2 c;
    c.f3();
    c.f1();
    return 0;
}
```

如果要以指針數組的方式調用子類成員函數，顯然只能用第一種