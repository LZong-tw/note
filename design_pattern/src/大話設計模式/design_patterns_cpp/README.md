# design_patterns

大話設計模式>> c++ 實現, 某些實現非常簡單的模式或是開發過程中用的少已經忽略

## Simple Factory Method, 簡單工廠 (Creational 創建型)

簡單工廠 ： 用來生產同一等級結構中的任意產品。（對於增加新的產品，無能為力）

創建型：它接受指令，創建出符合要求的實例

計算器選擇工廠模式的原因：　計算方法總是不變的

## Strategy, 策略模式 (Behavioral 行為型)

定義一系列的算法把它們一個個封裝起來，並且使他們可相互替換．本模式使得算法的變化可獨立於使用它的客戶．

行為型：它接受已經創建好的實例，實現不同的行為

商場收費軟件選擇策略模式的原因：　商場收費方式經常發生改變

## Decorator, 裝飾模式　（Structural 結構型)

動態的給一個對象添加一些額外的職責．

## proxy 代理模式（Structural 結構型)

real 和　proxy 類均繼承同樣的接口類，　proxy 裡面存儲　real　對象的指針，proxy　函數調用 real　的同名函數．

## Factory Method, 工廠模式 (Creational 創建型)

與簡單工廠模式的區別就是，每個不同的操作都有自己的工廠，然後由客戶端去決定去使用哪個子類工廠．

## Facade 外觀模式（Structural 結構型)

對一堆子類進行高層封裝，使高層封裝提供一致性界面．

## Builder 建造者模式 (Creational 創建型)

當創建複雜對象的算法（流程）應該獨立於具體的對象組成部分以及它們的裝配方式時使用該模式．創建對象的流程需要穩定，所有具體對象都遵循該流程．

## Observer 觀察者模式　(Behavioral 行為型)

類間相互耦合時，一個類的狀態發生變化需要通知其他類進行相應更新操作．

## Abstract Factory 抽象工廠模式 (Creational 創建型)

創建一系列相關或相互以來對象的接口，而無需指定它們具體的類．

## State 狀態模式　(Behavioral 行為型)

允許一個對象在其內部狀態改變時改變它的行為．對象看起來似乎修改了它的類．

## Memento 備忘錄　(Behavioral 行為型)

在不破壞封裝的前提下，捕獲一個對象的內部狀態，保存狀態，用以恢復原來的狀態，對象大時非常消耗內存．

## Singleton 單例模式

懶漢模式，　餓漢模式，　改進雙重鎖懶漢模式

## Command 命令模式

實現請求與執行的解耦和

## Chain of Responsibility 職責鏈模式
