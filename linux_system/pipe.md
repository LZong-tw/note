# PIPE


每個進程各自有不同的用戶地址空間，任何一個進程的全局變量在另一個進程中都看不到，所以進程之間要交換數據必須通過`內核`，在內核中開闢一塊緩衝區，進程1把數據從用戶空間拷到內核緩衝區，進程2再從內核緩衝區把數據讀走，內核提供的這種機制稱為進程間通信（IPC，InterProcess Communication）。如下圖所示。


![](images/process.ipc.png)

##实现机制：

管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。`一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用`。`当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失`。


## 关于管道的读写

管道实现的源代码在fs/pipe.c中，在pipe.c中有很多函数，其中有两个函数比较重要，即管道读函数pipe_read()和管道写函数pipe_wrtie()。管道写函数通过将字节复制到 VFS 索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。当然，`内核必须利用一定的机制同步对管道的访问`，为此，`内核使用了锁、等待队列和信号`。

当写进程向管道中写入时，它利用标准的库函数write()，系统根据库函数传递的文件描述符，`可找到该文件的 file 结构`。file 结构中指定了用来进行写操作的函数（即写入函数）地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查 VFS 索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：

- `内存中有足够的空间可容纳所有要写入的数据`
- `内存没有被读程序锁定`。

如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在 VFS 索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。

管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。

##管道

管道是一種最基本的IPC機制，由pipe函數創建：


```c
#include <unistd.h>

int pipe(int filedes[2]);
```
調用pipe函數時在`內核中開闢一塊緩衝區`（稱為管道）用於通信，它有一個讀端一個寫端，然後通過filedes參數傳出給用戶程序兩個文件描述符，filedes[0]指向管道的讀端，filedes[1]指向管道的寫端（很好記，就像0是標準輸入1是標準輸出一樣）。所以管道在用戶程序看起來就像一個打開的文件，通過read(filedes[0]);或者write(filedes[1]);向這個文件讀寫數據其實是在讀寫內核緩衝區。pipe函數調用成功返回0，調用失敗返回-1。

開闢了管道之後如何實現兩個進程間的通信呢？比如可以按下面的步驟通信。

![](images/process.pipe.png)


- 父進程調用pipe開闢管道，得到兩個文件描述符指向管道的兩端。

- 父進程調用`fork創建子進程`，那麼`子進程也有兩個文件描述符指向同一管道`。

- 父進程關閉管道讀端，子進程關閉管道寫端。父進程可以往管道里寫，子進程可以從管道里讀，管道是用環形隊列實現的，數據從寫端流入從讀端流出，這樣就實現了進程間通信。`


```c
#include <stdlib.h>
#include <unistd.h>
#define MAXLINE 80

int main(void)
{
    int n;
    int fd[2];
    pid_t pid;
    char line[MAXLINE];

    if (pipe(fd) < 0) {
        perror("pipe");
        exit(1);
    }

    if ((pid = fork()) < 0) {
        perror("fork");
        exit(1);
    }

    if (pid > 0) { /* parent */
        close(fd[0]);
        write(fd[1], "hello world\n", 12);
        wait(NULL);
    } else {       /* child */
        close(fd[1]);
        n = read(fd[0], line, MAXLINE);
        write(STDOUT_FILENO, line, n);
    }

    return 0;
}
```

### 使用管道有一些限制：

兩個進程通過一個管道只能實現`單向`通信，比如上面的例子，父進程寫子進程讀，如果有時候也需要子進程寫父進程讀，`就必須另開一個管道`。請讀者思考，如果只開一個管道，但是父進程不關閉讀端，子進程也不關閉寫端，雙方都有讀端和寫端，為什麼不能實現雙向通信？

管道的讀寫端通過打開的`文件描述符來傳遞`，因此要通信的`兩個進程必須從它們的公共祖先那裡繼承管道文件描述符`。上面的例子是父進程把文件描述符傳給子進程之後父子進程之間通信，也可以父進程fork兩次，把文件描述符傳給兩個子進程，然後兩個子進程之間通信，總之需要通過fork傳遞文件描述符使兩個進程都能訪問`同一管道`，它們才能通信。

使用管道需要注意以下4種特殊情況（假設都是阻塞I/O操作，沒有設置O_NONBLOCK標誌）：

- 如果所有指向管道寫端的文件描述符都關閉了（管道寫端的引用計數等於0），而仍然有進程從管道的讀端讀數據，那麼管道中剩餘的數據都被讀取後，再次read會返回0，就像讀到文件末尾一樣。

- 如果有指向管道寫端的文件描述符沒關閉（管道寫端的引用計數大於0），而持有管道寫端的進程也沒有向管道中寫數據，這時有進程從管道讀端讀數據，那麼管道中剩餘的數據都被讀取後，再次read會阻塞，直到管道中有數據可讀了才讀取數據並返回。

- 如果所有指向管道`讀端`的文件描述符`都關閉了`（管道讀端的引用計數等於0），`這時有進程向管道的寫端write，那麼該進程會收到信號SIGPIPE，通常會導致進程異常終止`。在第 33 章 信號會講到怎樣使SIGPIPE信號不終止進程。

- 如果有指向管道讀端的文件描述符沒關閉（管道讀端的引用計數大於0），而持有管道讀端的進程也沒有從管道中讀數據，這時有進程向管道寫端寫數據，那麼在管道被寫滿時再次write會阻塞，直到管道中有空位置了才寫入數據並返回。

管道的這四種特殊情況具有普遍意義。socket編程要講的TCP socket也具有管道的這些特性。

---

在Unix-like下，會盡量把裝置視為一個`檔案`，也就是說，所有對該裝置的讀取與寫入都可以視為對檔案進行讀取與寫入，`而每個檔案都會有一個編號，也就是file descriptor`，程式在讀取與寫入時指明目標file descriptor後，即可對該檔案進行所需要的操作。 每個程式執行時，Linux核心會自動提供一個file descriptor的table，負責紀錄這些檔案操作的紀錄，一般程式執行時，`預設會開啟三個檔案，stdin,stdout,stderr，程式的標準輸入輸出(scanf / printf cin cout之類的)，實際上就是對stdin,stdout進行讀取與寫入`。當你在`開檔的時候，程式會在file descriptor上面紀錄所需的資料後，將該筆資料的編號回傳給你`，以後就可以對這個編號進行讀取或寫入。而pipe也是如此，呼叫pipe指令時，Linux核心內會建立一個緩衝區，並在file descriptor table 中開啟兩個新的號碼，在這之後就可以利用這兩個號碼對資料進行讀取與寫入，寫入時會寫入到pipe裡的緩衝區，讀取時就是從緩衝區裡面取出資料，`緩衝區的部份由Linux核心提供支援，程式撰寫者並不需要去煩惱該部份的運作`。

###以上段落可以簡化成幾個重點

1.每個程式都有一張表，紀錄許多檔案編號，以及該檔案編號對應的資料，此部份由Linux核心支援，使用者不需要(也沒辦法)去知道該部份的實際運作情形

2.開檔的時候實際上就是在這張表裡面新增一筆資料，在讀寫檔案的時候必須同時提供該筆資料的編號

3.每個程式預設開啟stdin,stdout,stderr這三個檔案，分別置放於這張表的第0,1,2位置

相關的指令有pipe（呼叫system call建立pipe之後回傳file descriptor編號），dup2（複製file desciptor），詳細用法可以google，網路上資料很多

將其他筆檔案描述資料複製到fd_table的第0~2個位置以後，就可以將標準輸入輸出從鍵盤螢幕改到該檔案描述資料上，(例如說：我開了一個檔案編號是3，那我將第三個位置複製到第0個位置之後，所有從鍵盤輸入的資料就會改從由該檔案讀取資料)，利用這個方法來完成shell裡面的資料重新導向，程序之間的溝通之類的玩意。

實做上必須注意以下幾個重點

1.`有複製，就要有關閉，一個dup2搭一個close，保持file descriptor的單純性`
（此為血淚經驗談，自己實做就知道…）

2.fork出去的程式，沒用到的file descriptor一定要記得關
舉例來說，本來shell主程式裡面有一個pipe，若是此時fork出子程序來exec指令，主程序下wait指令等待子程序執行完畢且主程序沒有關閉pipe，則主程序會卡住。因為當fork的時候，一個pipe實際上會變成兩個pipe，當指派子程序接收pipe資料的時候，如果還有其他pipe沒有關閉，則子程序會判定pipe資料流尚未結束，而繼續痴痴等待輸入，`若是主程序有pipe沒關閉的話，結果就是主程序在等子程序結束，子程序又在等待主程序的pipe輸入資料，造成死結`。

--- 


## 實現兩個管道雙向數據流

```c
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main()
{
    int fd1[2], fd2[2], cld_pid;
    char buf[200], len;

    if (pipe(fd1) == -1) { // 創建管道1
        printf("creat pipe1 error\n");
        exit(1);
    }

    if (pipe(fd2) == -1) { // 創建管道2
        printf("creat pipe2 error\n");
        exit(1);
    }

    if ((cld_pid = fork()) == 0) { //子進程
        close(fd1[1]); // 子進程關閉管道1的寫入端
        close(fd2[0]); // 子進程關閉管道1的讀出端

        //子進程讀管道1
        len = read(fd1[0], buf, sizeof(buf));
        printf("\n這是在子進程：子進程從管道1中讀出的字符串 -- %s",
               buf);

        //子進程寫管道2
        strcpy(buf, "子進程寫入管道2的字符串");
        write(fd2[1], buf, strlen(buf));
        printf("\n這是在子進程：子進程成功寫入如下語句：%s\n", buf);

        exit(0);
    } else { //父進程
        close(fd1[0]); // 父進程關閉管道1的讀出端
        close(fd2[1]); // 父進程關閉管道2的寫入端

        //父進程寫管道1
        strcpy(buf, "父進程寫入管道1的字符串");
        write(fd1[1], buf, strlen(buf));
        printf("miaojing\n");

        //父進程讀管道2
        len = read(fd2[0], buf, sizeof(buf));
        printf("\n這是在父進程：父進程從管道2中讀出的字符串 -- %s\n",
               buf);
        exit(0);
    }
}
```

---

## 命名管道(named PIPE)

由于基于fork机制，所以管道`只能用于父进程和子进程之间，或者拥有相同祖先的两个子进程之间 (有亲缘关系的进程之间)`。为了解决这一问题，Linux提供了FIFO方式连接进程。FIFO又叫做命名管道(named PIPE)。

FIFO (First in, First out)为一种特殊的文件类型，它在文件系统中有对应的路径。当一个进程以读(r)的方式打开该文件，而另一个进程以写(w)的方式打开该文件，那么内核就会在这两个进程之间建立管道，所以FIFO实际上也由内核管理，不与硬盘打交道。之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。FIFO只是借用了文件系统(file system,命名管道是一种特殊类型的文件，因为Linux中所有事物都是文件，它在文件系统中`以文件名的形式存在`。)来为管道命名。写模式的进程向FIFO文件中写入，而读模式的进程从FIFO文件中读出。当删除FIFO文件时，管道连接也随之消失。FIFO的好处在于我们可以通过`文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接`


### 函数原型：

```c
#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char *filename, mode_t mode);
int mknode(const char *filename, mode_t mode | S_IFIFO, (dev_t) 0 );
```

其中pathname是被创建的文件名称，mode表示将在该文件上设置的权限位和将被创建的文件类型(在此情况下为S_IFIFO)，`dev是当创建设备特殊文件时使用的一个值`。因此，对于先进先出文件它的值为0。




```c
#include <stdio.h>  
#include <stdlib.h>  
#include <sys/types.h>  
#include <sys/stat.h>  
      
int main()  
{  
    int res = mkfifo("/tmp/my_fifo", 0777);  
    if (res == 0)  
    {  
        printf("FIFO created/n");  
    }  
    
    exit(EXIT_SUCCESS);  
}  
```


用ls命令查看所创建的管道

```c
$ ls -lF /tmp/my_fifo

prwxr-xr-x 1 root root 0 05-08 20:10 /tmp/my_fifo|
```

注意：ls命令的输出结果中的第一个字符为p，表示这是一个管道。最后的|符号是由ls命令的-F选项添加的，它也表示是这是一个管道。

## FIFO读写规则

1.从FIFO中读取数据： 约定：如果一个进程为了从FIFO中读取数据而阻塞打开了FIFO，那么称该进程内的读操作为设置了阻塞标志的读操作

2.从FIFO中写入数据： 约定：如果一个进程为了向FIFO中写入数据而阻塞打开FIFO，那么称该进程内的写操作为设置了阻塞标志的写操作。


## 總結 

匿名通道和具名通道有以下特點

- 通道是特殊類型檔案，在滿足先入先出的原則下可以進行讀寫，但無法定位讀寫位置。
- 通道是`單向`的，若要實現雙向，則需利用兩個通道。匿名通道一般只適用於親屬關係的process之間通訊(非親緣關係的process只能傳遞file descriptor)，而具名通道是以磁碟檔案的方式存在，可以完成本機任意兩個process 之間的通訊。
- 阻塞問題。 匿名通道無須特別開啟，建立時直接返回file descriptor，`而在讀寫錢需先確定對方的存在，亦即阻塞於讀寫位置`。開啟具名通道時也要確定對方的存在，否則阻塞
-